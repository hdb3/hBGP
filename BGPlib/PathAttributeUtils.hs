{-# LANGUAGE Strict #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE FlexibleInstances #-}
{-#LANGUAGE OverloadedStrings #-}
module BGPlib.PathAttributeUtils where
import Data.Word
import Data.IP
import Data.Maybe(fromJust,fromMaybe)
import Data.List(delete)

import BGPlib.PathAttributes

prePendAS :: ASNumber a => a -> [PathAttribute] -> [PathAttribute]
prePendAS asn = updatePathAttribute TypeCodePathAttributeASPath (asPrePend' asn) where
    asPrePend' asn ( PathAttributeASPath p) = PathAttributeASPath (asPrePend asn p)

getASPathLength :: [PathAttribute] -> Int
getASPathLength = error "deprecated - use get ASPathDetail or write a wrapper for it"

-- normaliseASPath:  eliminate as4 path by replacing the original as2 path with the contens of the as4 path
-- should be a lossless conversion
-- the reverse would be needed if talking to an as2 only peer...
normaliseASPath pas = let toASPath4' (PathAttributeASPath p) = PathAttributeASPath (toASPath4 p)
                          pas' = updatePathAttribute TypeCodePathAttributeASPath toASPath4' pas in
    maybe pas'
          (\(PathAttributeAS4Path path) -> deletePathAttributeType TypeCodePathAttributeAS4Path $ insertPathAttribute (PathAttributeASPath (toASPath4 path)) pas)
          (getPathAttribute TypeCodePathAttributeAS4Path pas)

getAS2Path = fromJust . getPathAttribute TypeCodePathAttributeASPath
getAS4Path = fromJust . getPathAttribute TypeCodePathAttributeAS4Path

getASPathAttribute pax = fromMaybe (getAS2Path pax) (getPathAttribute TypeCodePathAttributeAS4Path pax)

getASPathDetail :: [PathAttribute] -> (Int, Word32, Word32)
getASPathDetail = detail . getASPathContent where
    detail [] = (0,0,0)
    detail [ASSequence seq] = (length seq, last seq, head seq)
    detail _ = error "AS Set and multi Sequence detail not written yet"
    
elemASPath :: Word32 -> [PathAttribute] -> Bool
elemASPath asn = go . getASPathContent where
    go [] = False
    go [ASSequence seq] = go2 seq
    go _ = error "AS Set and multi Sequence elemASPath not written yet"
    go2 [] = False
    go2 (a:ax) = a == asn || go2 ax

getASPath :: [PathAttribute] -> ASPath
getASPath = unwrapASPath . getASPathAttribute where
    unwrapASPath (PathAttributeASPath asPath) = asPath
    unwrapASPath (PathAttributeAS4Path asPath) = asPath

getASPathContent :: [PathAttribute] -> [ASSegment Word32]
getASPathContent = unwrapSegments . toASPath4 . getASPath where
    unwrapSegments (ASPath4 segments) = segments

flattenPath :: [ASSegment Word32] -> [Word32]
flattenPath [] = []
flattenPath (ASSequence []:segs) = flattenPath segs
flattenPath (ASSequence asns:segs) = asns ++ flattenPath segs
flattenPath (ASSet []:segs) = flattenPath segs
flattenPath (ASSet asns:segs) = head asns : flattenPath segs

setLocalPref :: Word32 -> [PathAttribute] -> [PathAttribute]
setLocalPref = insertPathAttribute . PathAttributeLocalPref

delLocalPref :: [PathAttribute] -> [PathAttribute]
delLocalPref = deletePathAttributeType TypeCodePathAttributeLocalPref

getLocalPref :: [PathAttribute] -> Word32
getLocalPref pas = maybe 0 (\(PathAttributeLocalPref x) -> x) (getPathAttribute TypeCodePathAttributeLocalPref pas)

setMED :: Word32 -> [PathAttribute] -> [PathAttribute]
setMED = insertPathAttribute . PathAttributeMultiExitDisc

getMED :: [PathAttribute] -> Word32
getMED pas = maybe 0 (\(PathAttributeMultiExitDisc x) -> x) (getPathAttribute TypeCodePathAttributeMultiExitDisc pas)

setOrigin :: Word8 -> [PathAttribute] -> [PathAttribute]
setOrigin = insertPathAttribute . PathAttributeOrigin

getOrigin :: [PathAttribute] -> Word8
getOrigin pas = maybe 0 (\(PathAttributeOrigin x) -> x ) (getPathAttribute TypeCodePathAttributeOrigin pas)

setNextHop :: IPv4 -> [PathAttribute] -> [PathAttribute]
setNextHop = insertPathAttribute . PathAttributeNextHop

getNextHop :: [PathAttribute] -> IPv4
getNextHop pas = maybe "127.0.0.127" (\(PathAttributeNextHop x) -> x ) (getPathAttribute TypeCodePathAttributeNextHop pas)

checkForRequiredPathAttributes :: [PathAttribute] -> Bool
checkForRequiredPathAttributes pas = included requiredPathAttributes (map identify pas)


-- there may be a standard way to express this - the requirement is that all elements of the list requiredPathAttributes
-- are in the list generated by '(map identify pas)'
-- note that this is a test for presence not equality

included [] _ = True
included ax [] | not (null ax) = False
included ax (b:bx) = included (delete b ax) bx
