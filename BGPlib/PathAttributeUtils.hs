{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE MultiWayIf #-}
{-# LANGUAGE OverloadedStrings #-}

module BGPlib.PathAttributeUtils where

import BGPlib.PathAttributes
import Data.IP
import Data.List (delete)
import Data.Maybe (fromJust, fromMaybe)
import Data.Word

prePendAS :: ASNumber -> [PathAttribute] -> [PathAttribute]
prePendAS asn = updatePathAttribute TypeCodePathAttributeASPath (asPrePend' asn)
  where
    asPrePend' asn (PathAttributeASPath p) = PathAttributeASPath (asPrePend asn p)
    asPrePend' asn attr = error "can only prepend to paths"

getASPathLength :: [PathAttribute] -> Int
getASPathLength pas =
  maybe
    0
    (\(PathAttributeASPath asPath) -> asPathLength asPath)
    (getPathAttribute TypeCodePathAttributeASPath pas)

-- normaliseASPath:  eliminate as4 path by replacing the original as2 path with the contens of the as4 path
-- should be a lossless conversion
-- the reverse would be needed if talking to an as2 only peer...
normaliseASPath pas =
  let toASPath4' (PathAttributeASPath p) = PathAttributeASPath p
      toASPath4' attr = error "can only normalise paths"
      pas' = updatePathAttribute TypeCodePathAttributeASPath toASPath4' pas
   in maybe
        pas'
        (\(PathAttributeAS4Path path) -> deletePathAttributeType TypeCodePathAttributeAS4Path $ insertPathAttribute (PathAttributeASPath path) pas)
        (getPathAttribute TypeCodePathAttributeAS4Path pas)

getAS2Path = fromJust . getPathAttribute TypeCodePathAttributeASPath

getAS4Path = fromJust . getPathAttribute TypeCodePathAttributeAS4Path

getASPathAttribute pax = fromMaybe (getAS2Path pax) (getPathAttribute TypeCodePathAttributeAS4Path pax)

getASPathList :: [PathAttribute] -> String
getASPathList = list . getASPathContent
  where
    list [] = "[]"
    list [ASSequence seq] = show seq
    list [ASSet set] = show set
    list _ = error "AS Set and multi Set/Sequence detail not written yet"

getASPathDetail :: [PathAttribute] -> (Int, Word32, Word32)
getASPathDetail = detail . getASPathContent
  where
    detail [] = (0, 0, 0)
    detail [ASSequence seq] = (length seq, last seq, head seq)
    detail [ASSet set] = (length set, last set, head set)
    detail _ = error "AS Set and multi Sequence detail not written yet"

elemASPath :: Word32 -> [PathAttribute] -> Bool
elemASPath asn = go . getASPathContent
  where
    go [] = False
    go (a : ax) = go' a || go ax
    go' (ASSet set) = go'' set
    go' (ASSequence seq) = go'' seq
    go'' [] = False
    go'' (a : ax) = a == asn || go'' ax

getASPath :: [PathAttribute] -> ASPath
getASPath = unwrapASPath . getASPathAttribute
  where
    unwrapASPath (PathAttributeASPath asPath) = asPath
    unwrapASPath (PathAttributeAS4Path asPath) = asPath
    unwrapASPath _ = error "cant unwrap paths from not-paths"

getASPathContent :: [PathAttribute] -> [ASSegment]
getASPathContent = getASPath

--getASPathContent = unwrapSegments . toASPath4 . getASPath where
--unwrapSegments (ASPath4 segments) = segments
-- getASPathContent (PathAttributeASPath (ASPath4 segments)) = segments
-- getASPathContent (PathAttributeASPath (ASPath2 segments)) = map toASPath4 segments

getASPathSegmentCount = length . getASPathContent

getASPathOrigin = getLastASN . last . getASPathContent

-- getLastASN :: ASSegment Word32 -> Word32
getLastASN (ASSequence ax) = last ax
getLastASN (ASSet ax) = head ax

setLocalPref :: Word32 -> [PathAttribute] -> [PathAttribute]
setLocalPref = insertPathAttribute . PathAttributeLocalPref

delLocalPref :: [PathAttribute] -> [PathAttribute]
delLocalPref = deletePathAttributeType TypeCodePathAttributeLocalPref

getLocalPref :: [PathAttribute] -> Word32
getLocalPref pas = maybe 0 (\(PathAttributeLocalPref x) -> x) (getPathAttribute TypeCodePathAttributeLocalPref pas)

setMED :: Word32 -> [PathAttribute] -> [PathAttribute]
setMED = insertPathAttribute . PathAttributeMultiExitDisc

getMED :: [PathAttribute] -> Maybe Word32
getMED pas = fmap (\(PathAttributeMultiExitDisc x) -> x) (getPathAttribute TypeCodePathAttributeMultiExitDisc pas)

setOrigin :: Word8 -> [PathAttribute] -> [PathAttribute]
setOrigin = insertPathAttribute . PathAttributeOrigin

getOrigin :: [PathAttribute] -> Word8
getOrigin pas = maybe 0 (\(PathAttributeOrigin x) -> x) (getPathAttribute TypeCodePathAttributeOrigin pas)

setNextHop :: IPv4 -> [PathAttribute] -> [PathAttribute]
setNextHop = insertPathAttribute . PathAttributeNextHop

getNextHop :: [PathAttribute] -> IPv4
getNextHop pas = maybe "127.0.0.127" (\(PathAttributeNextHop x) -> x) (getPathAttribute TypeCodePathAttributeNextHop pas)

checkForRequiredPathAttributes :: [PathAttribute] -> Bool
checkForRequiredPathAttributes pas = included requiredPathAttributes (map identify pas)

-- there may be a standard way to express this - the requirement is that all elements of the list requiredPathAttributes
-- are in the list generated by '(map identify pas)'
-- note that this is a test for presence not equality
-- i think Data.list has something.....

included [] _ = True
included ax [] | not (null ax) = False
included ax (b : bx) = included (delete b ax) bx
included _ _ = error "included: unthougt of combination"
